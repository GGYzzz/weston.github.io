{"meta":{"title":"Weston's blog","subtitle":"","description":"","author":"Weston","url":"https://weston-wey.github.io","root":"/"},"pages":[{"title":"关于","date":"13/06/2020","updated":"13/06/2020","comments":false,"path":"about/index.html","permalink":"https://weston-wey.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"14/06/2020","updated":"13/06/2020","comments":false,"path":"categories/index.html","permalink":"https://weston-wey.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"13/06/2020","updated":"13/06/2020","comments":false,"path":"/404.html","permalink":"https://weston-wey.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"14/06/2020","updated":"13/06/2020","comments":false,"path":"books/index.html","permalink":"https://weston-wey.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"13/06/2020","updated":"13/06/2020","comments":true,"path":"links/index.html","permalink":"https://weston-wey.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"14/06/2020","updated":"13/06/2020","comments":false,"path":"tags/index.html","permalink":"https://weston-wey.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"13/06/2020","updated":"13/06/2020","comments":false,"path":"repository/index.html","permalink":"https://weston-wey.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis设计与实现读书笔记：数据结构与对象之简单动态字符串","date":"17/06/2020","path":"Redis设计与实现读书笔记：数据结构与对象之简单动态字符串/","text":"一、定义：简单动态字符串（simple dynamic string，SDS） redis没有使用 C语言提供的字符串类型，而是自定义了 sds的结构体： 12345678910struct sdshdr &#123; // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];&#125;; 二、内存分配底层优化 C语言字符串的内存分配策略：事实分配与回收 扩展：程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生 缓冲区溢出 缩减：程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生 内存泄漏 redis优化： 扩展：空间预分配 如果扩展后，SDS长度 &lt; 1MB，则分配空间大小 = len + free(=len)【即：分配 2倍的空间】 如果扩展后，SDS长度 &gt; 1MB，则分配空间大小= len + free(1MB) 缩减：惰性空间释放 不直接释放，而是将释放的空间作为未使用空间保存在 SDS中，下次需要时可以直接使用 提供 API：sdsfree，来真正释放空间 三、SDS相对于 C字符串的优势 表：C 字符串和 SDS 之间的区别 C 字符串 SDS 获取字符串长度的复杂度为 。 获取字符串长度的复杂度为 。 API 是不安全的，可能会造成缓冲区溢出。 API 是安全的，不会造成缓冲区溢出。 修改字符串长度 N 次必然需要执行 N 次内存重分配。 修改字符串长度 N 次最多需要执行 N 次内存重分配。 只能保存文本数据。 可以保存文本或者二进制数据。 可以使用所有 `` 库中的函数。 可以使用一部分 `` 库中的函数。 优势： 可以快速（O(1)）获取字符串长度 不会造成缓冲区溢出：字符串赋值会先检查容量是否够用 提高 修改字符串的效率：预分配 + 懒回收机制 二进制安全：底层是字符数组，没有 '\\0’的语义，所以可以存二进制数据而不会造成被 '\\0’莫名截断的问题 兼容 C的字符串函数","content":"<h3 id=\"一-定义简单动态字符串simple-dynamic-stringsds\"><a class=\"markdownIt-Anchor\" href=\"#一-定义简单动态字符串simple-dynamic-stringsds\"></a> 一、定义：简单动态字符串（simple dynamic string，SDS）</h3>\n<p>redis没有使用 C语言提供的字符串类型，而是自定义了 sds的结构体：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sdshdr</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 记录 buf 数组中已使用字节的数量</span></span><br><span class=\"line\">    <span class=\"comment\">// 等于 SDS 所保存字符串的长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">// 记录 buf 数组中未使用字节的数量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 字节数组，用于保存字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-内存分配底层优化\"><a class=\"markdownIt-Anchor\" href=\"#二-内存分配底层优化\"></a> 二、内存分配底层优化</h3>\n<ul>\n<li>\n<p>C语言字符串的内存分配策略：事实分配与回收</p>\n<ol>\n<li>扩展：程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生 <strong>缓冲区溢出</strong></li>\n<li>缩减：程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生 <strong>内存泄漏</strong></li>\n</ol>\n</li>\n<li>\n<p>redis优化：</p>\n<ol>\n<li>扩展：<mark>空间预分配</mark>\n<ul>\n<li>如果扩展后，SDS长度 &lt; 1MB，则分配空间大小 = len + free(=len)【即：分配 2倍的空间】</li>\n<li>如果扩展后，SDS长度 &gt; 1MB，则分配空间大小= len + free(1MB)</li>\n</ul>\n</li>\n<li>缩减：<mark>惰性空间释放</mark>\n<ol>\n<li>不直接释放，而是将释放的空间作为未使用空间保存在 SDS中，下次需要时可以直接使用</li>\n<li>提供 API：sdsfree，来真正释放空间</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"三-sds相对于-c字符串的优势\"><a class=\"markdownIt-Anchor\" href=\"#三-sds相对于-c字符串的优势\"></a> 三、SDS相对于 C字符串的优势</h3>\n<p>表：C 字符串和 SDS 之间的区别</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">C 字符串</th>\n<th style=\"text-align:left\">SDS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">获取字符串长度的复杂度为 <img src=\"https://box.kancloud.cn/2015-09-13_55f50e14dc650.png\" alt=\"O(N)\"> 。</td>\n<td style=\"text-align:left\">获取字符串长度的复杂度为 <img src=\"https://box.kancloud.cn/2015-09-13_55f50e22eca8b.png\" alt=\"O(1)\"> 。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">API 是不安全的，可能会造成缓冲区溢出。</td>\n<td style=\"text-align:left\">API 是安全的，不会造成缓冲区溢出。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">修改字符串长度 <code>N</code> 次必然需要执行 <code>N</code> 次内存重分配。</td>\n<td style=\"text-align:left\">修改字符串长度 <code>N</code> 次最多需要执行 <code>N</code> 次内存重分配。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">只能保存文本数据。</td>\n<td style=\"text-align:left\">可以保存文本或者二进制数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可以使用所有 `` 库中的函数。</td>\n<td style=\"text-align:left\">可以使用一部分 `` 库中的函数。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>优势：\n<ol>\n<li>可以快速（O(1)）获取字符串长度</li>\n<li>不会造成缓冲区溢出：字符串赋值会先检查容量是否够用</li>\n<li>提高 修改字符串的效率：预分配 + 懒回收机制</li>\n<li>二进制安全：底层是字符数组，没有 '\\0’的语义，所以可以存二进制数据而不会造成被 '\\0’莫名截断的问题</li>\n<li>兼容 C的字符串函数</li>\n</ol>\n</li>\n</ul>\n","excerpt":"","categories":[{"name":"redis设计与实现读书笔记","slug":"redis设计与实现读书笔记","permalink":"https://weston-wey.github.io/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://weston-wey.github.io/tags/redis/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://weston-wey.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"6月14 剑指offer二刷复习","date":"14/06/2020","path":"6月14-剑指offer二刷复习/","text":"1、用两个栈实现队列【easy】 思路： 栈：先进后出；队列：先进先出 对于对于一批数据来说，先入栈的，最后出栈；于是，如果要是能把入栈的这一批数据倒叙过来就好了； 栈有记忆功能，这正是栈能派上用场的地方！ 因此基本思路就是：一个栈A 尽管入，当要出队时，把这一批数据用另一个栈B 做个倒叙就可以了。 实现： 123456789101112131415161718192021222324252627class CQueue &#123; public static Stack&lt;Integer&gt; stack1; public static Stack&lt;Integer&gt; stack2; public CQueue() &#123; stack1=new Stack&lt;&gt;(); stack2=new Stack&lt;&gt;(); &#125; public void appendTail(int value) &#123; // 入栈即可 stack1.push(value); &#125; public int deleteHead() &#123; // 出队时，把数据全部做一次逆序即可 if(!stack2.empty())&#123; // 栈2不空，说明已经有之前逆序过的数据了，直接出队即可； return stack2.pop(); &#125;else&#123; // 栈2为空 while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; return stack2.empty() ? -1 : stack2.pop(); &#125; &#125;&#125; 2、求斐波那契数列的第 n项【easy】 三种思路： 递归：简单、直观，但是重复计算太大，不可能通过测试用例 记忆化递归：用数组把算过的值记下来，避免大量重复计算 可以解决问题，但是有方法栈的开销 动态规划：自底向上，经过空间优化的空间复杂度可以达到 O(1) 实现： 1234567891011class Solution &#123; public int fib(int n) &#123; int a = 0, b = 1, res; for(int i = 2; i &lt;= n; i++)&#123; res = (a + b) % 1000000007; a = b; b = res; &#125; return res; &#125;&#125; 3、数组中重复的数字，返回任一个重复的即可【easy】 三种思路： 集合去重：提到去重，就应想到集合：遍历一遍并放入HashSet，如果集合中已经有了，那直接返回该值即可 数组去重：当数组值的范围有限【例如字符串中的字母去重】，可以考虑直接用一定大小的数组去重【比如int[24]】 该题的特殊点：数组中的值都在 0~n-1之间，因此直接用本身就可以了；原地置换思路： 遍历数组，把当前的数字nums[i] 和对应索引的值进行交换 每一次都会把一个数字放到最终的位置【数字值等于索引值的位置】 遇到对应位置已经存在相等的值了，说明重复了，直接返回即可 实现： 123456789101112131415161718class Solution &#123; public int findRepeatNumber(int[] nums) &#123; for(int i=0; i&lt;nums.length; i++)&#123; // 如果不在最终位置 while(nums[i]!=i)&#123; // 交换前判断是否重复 if(nums[i]==nums[nums[i]])&#123; return nums[i]; &#125; // 需要交换 int temp=nums[i]; nums[i]=nums[nums[i]]; nums[temp]=temp; &#125; &#125; return -1; &#125;&#125; 4、二维数组中查找某个值 target是否存在【easy】 两种思路： 直接遍历即可，时间复杂度：O(n^2) 二分法，利用二维数组的特殊性： 每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序 因此不必从头开始遍历，而是利用到数组的特性：从右上角（或左下角）出发，只能向左或者向下走，因为左边的值都小于当前值，而下变的值都大于当前值。因此每一步必定要么向左，要么向下，从而充分利用了数组的特性，达到了“二分法”的效果 时间复杂度：O(max(rows, cols)) 5、青蛙🐸跳台阶问题【easy】 与斐波那契数列一摸一样，换了个描述方式而已（直接把斐波那契那道题的代码拷过来就能AC） 6、旋转数组的最小数字：找旋转点【easy】 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 两种思路： 遍历一遍的思路谁都想的出来，时间复杂度 O(n)；【O(n)已经挺好的了呀，于是进一步优化至 O(logn)】 提到有序数组的查找，就应立马想到二分法：时间复杂度O(logn)，但这是一个不完全有序的数组，还能用到二分法吗？答案是肯定的。 实现：【算法流程可以画图理解，清晰的一b】 一般情况：（用来写算法框架） 特殊情况：（用来考虑算法细节，真正需要debug的地方在这里！） [1，2，3，4，5]，旋转个数为0 [1，1，1，0，1]、[1，0，1，1，1]，很鸡贼的旋转 12345678910111213141516class Solution &#123; public int minArray(int[] numbers) &#123; // 找旋转点 int left=0,right=numbers.length-1,mid; while(left&lt;right)&#123; mid=(left+right)/2; if(numbers[mid]&gt;numbers[right])&#123; //旋转点一定在右边 left=mid+1; &#125;else if(numbers[mid]&lt;numbers[right])&#123; //当前有可能踩着旋转点 right=mid; &#125;else&#123; //当前有可能踩着旋转点 --right; &#125; &#125; return numbers[left]; &#125;&#125;","content":"<h3 id=\"1-用两个栈实现队列easy\"><a class=\"markdownIt-Anchor\" href=\"#1-用两个栈实现队列easy\"></a> 1、<a href=\"https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\" target=\"_blank\" rel=\"noopener\">用两个栈实现队列</a>【easy】</h3>\n<ul>\n<li>\n<p>思路：</p>\n<ul>\n<li>栈：先进后出；队列：先进先出</li>\n<li>对于对于一批数据来说，先入栈的，最后出栈；于是，如果要是能把入栈的这一批数据倒叙过来就好了；</li>\n<li><mark>栈有记忆功能</mark>，这正是栈能派上用场的地方！</li>\n<li>因此基本思路就是：一个栈A 尽管入，当要出队时，把这一批数据用另一个栈B 做个倒叙就可以了。</li>\n</ul>\n</li>\n<li>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stack&lt;Integer&gt; stack1;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stack&lt;Integer&gt; stack2;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        stack1=<span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack2=<span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈即可</span></span><br><span class=\"line\">        stack1.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出队时，把数据全部做一次逆序即可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!stack2.empty())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 栈2不空，说明已经有之前逆序过的数据了，直接出队即可；</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> stack2.pop();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 栈2为空</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stack1.empty())&#123;</span><br><span class=\"line\">                stack2.push(stack1.pop());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> stack2.empty() ? -<span class=\"number\">1</span> : stack2.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"2-求斐波那契数列的第-n项easy\"><a class=\"markdownIt-Anchor\" href=\"#2-求斐波那契数列的第-n项easy\"></a> 2、<a href=\"https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/\" target=\"_blank\" rel=\"noopener\">求斐波那契数列的第 n项</a>【easy】</h3>\n<ul>\n<li>\n<p>三种思路：</p>\n<ol>\n<li>递归：简单、直观，但是重复计算太大，不可能通过测试用例</li>\n<li>记忆化递归：用数组把算过的值记下来，避免大量重复计算\n<ul>\n<li>可以解决问题，但是有方法栈的开销</li>\n</ul>\n</li>\n<li>动态规划：自底向上，经过空间优化的空间复杂度可以达到 O(1)</li>\n</ol>\n</li>\n<li>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>, b = <span class=\"number\">1</span>, res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            res = (a + b) % <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">            a = b;</span><br><span class=\"line\">            b = res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"3-数组中重复的数字返回任一个重复的即可easy\"><a class=\"markdownIt-Anchor\" href=\"#3-数组中重复的数字返回任一个重复的即可easy\"></a> 3、<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\" target=\"_blank\" rel=\"noopener\">数组中重复的数字，返回任一个重复的即可</a>【easy】</h3>\n<ul>\n<li>\n<p>三种思路：</p>\n<ol>\n<li><mark>集合去重：提到去重，就应想到集合</mark>：遍历一遍并放入HashSet，如果集合中已经有了，那直接返回该值即可</li>\n<li><mark>数组去重：当数组值的范围有限【例如字符串中的字母去重】，可以考虑直接用一定大小的数组去重【比如int[24]】</mark></li>\n<li>该题的特殊点：数组中的值都在 0~n-1之间，因此直接用本身就可以了；原地置换思路：\n<ol>\n<li>遍历数组，把当前的数字nums[i] 和对应索引的值进行交换</li>\n<li>每一次都会把一个数字放到最终的位置【数字值等于索引值的位置】</li>\n<li>遇到对应位置已经存在相等的值了，说明重复了，直接返回即可</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果不在最终位置</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(nums[i]!=i)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 交换前判断是否重复</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 需要交换</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp=nums[i];</span><br><span class=\"line\">                nums[i]=nums[nums[i]];</span><br><span class=\"line\">                nums[temp]=temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"4-二维数组中查找某个值-target是否存在easy\"><a class=\"markdownIt-Anchor\" href=\"#4-二维数组中查找某个值-target是否存在easy\"></a> 4、<a href=\"https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\" target=\"_blank\" rel=\"noopener\">二维数组中查找某个值 target是否存在</a>【easy】</h3>\n<ul>\n<li>\n<p>两种思路：</p>\n<ol>\n<li>\n<p>直接遍历即可，时间复杂度：O(n^2)</p>\n</li>\n<li>\n<p>二分法，利用二维数组的特殊性：</p>\n<blockquote>\n<p>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</p>\n</blockquote>\n<p>因此不必从头开始遍历，而是利用到数组的特性：从右上角（或左下角）出发，只能向左或者向下走，因为左边的值都小于当前值，而下变的值都大于当前值。因此每一步必定要么向左，要么向下，从而充分利用了数组的特性，达到了“二分法”的效果</p>\n<ul>\n<li>时间复杂度：O(max(rows, cols))</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"5-青蛙跳台阶问题easy\"><a class=\"markdownIt-Anchor\" href=\"#5-青蛙跳台阶问题easy\"></a> 5、<a href=\"https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof\" target=\"_blank\" rel=\"noopener\">青蛙🐸跳台阶问题</a>【easy】</h3>\n<ul>\n<li>与斐波那契数列一摸一样，换了个描述方式而已（直接把斐波那契那道题的代码拷过来就能AC）</li>\n</ul>\n<h3 id=\"6-旋转数组的最小数字找旋转点easy\"><a class=\"markdownIt-Anchor\" href=\"#6-旋转数组的最小数字找旋转点easy\"></a> 6、<a href=\"https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\" target=\"_blank\" rel=\"noopener\">旋转数组的最小数字：找旋转点</a>【easy】</h3>\n<blockquote>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个<strong>递增排序</strong>的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>\n<p>来源：力扣（LeetCode）<br>\n链接：<a href=\"https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n</blockquote>\n<ul>\n<li>\n<p>两种思路：</p>\n<ol>\n<li>\n<p>遍历一遍的思路谁都想的出来，时间复杂度 O(n)；【O(n)已经挺好的了呀，于是进一步优化至 O(logn)】</p>\n</li>\n<li>\n<p><mark>提到有序数组的查找，就应立马想到二分法：时间复杂度O(logn)</mark>，但这是一个不完全有序的数组，还能用到二分法吗？答案是肯定的。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>实现：【算法流程可以画图理解，清晰的一b】</p>\n<ol>\n<li>一般情况：（用来写算法框架）</li>\n</ol>\n<p><img src=\"/6%E6%9C%8814-%E5%89%91%E6%8C%87offer%E4%BA%8C%E5%88%B7%E5%A4%8D%E4%B9%A0/image-20200614231556957.png\" alt=\"normal\"></p>\n<ol start=\"2\">\n<li>特殊情况：（用来考虑算法细节，真正需要debug的地方在这里！）\n<ul>\n<li>[1，2，3，4，5]，旋转个数为0</li>\n<li>[1，1，1，0，1]、[1，0，1，1，1]，很鸡贼的旋转</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123; <span class=\"comment\">// 找旋转点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left=<span class=\"number\">0</span>,right=numbers.length-<span class=\"number\">1</span>,mid;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left&lt;right)&#123;</span><br><span class=\"line\">            mid=(left+right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(numbers[mid]&gt;numbers[right])&#123; <span class=\"comment\">//旋转点一定在右边</span></span><br><span class=\"line\">                left=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[mid]&lt;numbers[right])&#123; <span class=\"comment\">//当前有可能踩着旋转点</span></span><br><span class=\"line\">                right=mid;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//当前有可能踩着旋转点</span></span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","excerpt":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://weston-wey.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"数据结构与算法/剑指offer","permalink":"https://weston-wey.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://weston-wey.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://weston-wey.github.io/tags/LeetCode/"}]},{"title":"网易传媒Java实习面经","date":"14/06/2020","path":"网易传媒Java实习面经/","text":"记录面经，许愿offer。 基础知识 知道哪些集合 HashMap底层原理（每次都问这个我都吐了） 怎么让 HashMap退化成链表 他想说 重写hashcode方法，说了半天都没答到他想知道的点 对红黑树的了解？【这个太麻烦了，我每次都说红黑树是一个类似平衡二叉树的东西，其他就没有了】 你对多线程的了解有哪些 线程池如何去实现 线程池的处理流程 线程池创建的几个参数 你搞的项目有用到线程池吗 为什么要有多线程 多线程一定会加速程序的执行吗 电话也能问算法 如何判断链表是否有环【2种方法】 爬楼梯/青蛙跳台阶 /斐波那契数列【动态规划】 MySQL索引，对 B+树的理解 二叉树，平衡二叉树，B树，为什么要选用 B+树做索引 设计模式，单例模式","content":"<p>记录面经，许愿offer。</p>\n<a id=\"more\"></a>\n<h2 id=\"基础知识\"><a class=\"markdownIt-Anchor\" href=\"#基础知识\"></a> 基础知识</h2>\n<ol>\n<li>\n<p>知道哪些集合</p>\n</li>\n<li>\n<p>HashMap底层原理（每次都问这个我都吐了）</p>\n</li>\n<li>\n<p>怎么让 HashMap退化成链表</p>\n</li>\n<li>\n<ul>\n<li>他想说 重写hashcode方法，说了半天都没答到他想知道的点</li>\n</ul>\n</li>\n<li>\n<p>对红黑树的了解？【这个太麻烦了，我每次都说红黑树是一个类似平衡二叉树的东西，其他就没有了】</p>\n</li>\n<li>\n<p>你对多线程的了解有哪些</p>\n</li>\n<li>\n<p>线程池如何去实现</p>\n</li>\n<li>\n<p>线程池的处理流程</p>\n</li>\n<li>\n<p>线程池创建的几个参数</p>\n</li>\n<li>\n<p><mark>你搞的项目有用到线程池吗</mark></p>\n</li>\n<li>\n<p><mark>为什么要有多线程</mark></p>\n</li>\n<li>\n<p>多线程一定会加速程序的执行吗</p>\n</li>\n</ol>\n<h2 id=\"电话也能问算法\"><a class=\"markdownIt-Anchor\" href=\"#电话也能问算法\"></a> 电话也能问算法</h2>\n<ol>\n<li>\n<p>如何判断链表是否有环【2种方法】</p>\n</li>\n<li>\n<p>爬楼梯/青蛙跳台阶 /斐波那契数列【动态规划】</p>\n</li>\n<li>\n<p>MySQL索引，对 B+树的理解</p>\n</li>\n<li>\n<p>二叉树，平衡二叉树，B树，为什么要选用 B+树做索引</p>\n</li>\n<li>\n<p>设计模式，单例模式</p>\n</li>\n</ol>\n","excerpt":"记录面经，许愿offer。","categories":[{"name":"实习面经","slug":"实习面经","permalink":"https://weston-wey.github.io/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"网易传媒技术部","slug":"网易传媒技术部","permalink":"https://weston-wey.github.io/tags/%E7%BD%91%E6%98%93%E4%BC%A0%E5%AA%92%E6%8A%80%E6%9C%AF%E9%83%A8/"},{"name":"Java实习面经","slug":"Java实习面经","permalink":"https://weston-wey.github.io/tags/Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"}]},{"title":"hexo简单使用手册","date":"14/06/2020","path":"hexo简单使用手册/","text":"记录下hexo的基础用法，同时希望自己能够坚持写下去 🐱‍🏍 安装 安装就暂时先略过，可参考其他教程，本篇主要记录 hexo的使用；插眼：hexo中文文档 写文章 创建一篇新文章 1hexo new [layout] &lt;title&gt; 指定分类和标签 12345678910# 1. 用 -的形式只能写一个分类# 2. 若想用多个分类则：categories:# - [Diary, PlayStation]# - [Diary, Games]# - [Life]categories: - Diarytags: - PS3 - Games 文章摘要和截断 在文章中使用&lt;!--more--&gt;，那么之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中 写文章之插入图片 统一存放 优点：在首页内容和文章正文中都能正常显示,十分方便 缺点： 因为相对路径不一致,找不到文件，本地markdown 编辑器无法预览 图片几乎无法维护 生成每篇文章专属图片文件夹：在_config.yml配置 1post_asset_folder: true 配置后怎么用：当用 hexo new article_name 命令时，不仅会在 source/_post 文件夹自动生成文件： article_name.md还会生成同名文件夹： source/_post/article_name，这样就可以直接通过资源名引用了 举例： 123# 图片位置：source/_posts/article_name/image.jpg# 直接引用：![](image.jpg) 一键部署：将 Hexo 部署到 GitHub Pages 12345678# 可选：清除 public文件夹hexo clean# 1、生成（generate）hexo g# 可选：进行本地预览（server）hexo s# 2、一键部署（deploy）hexo d 💥","content":"<p>记录下hexo的基础用法，同时希望自己能够坚持写下去 🐱‍🏍</p>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\"></a> 安装</h2>\n<p>安装就暂时先略过，可参考其他教程，本篇主要记录 hexo的使用；插眼：<a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">hexo中文文档</a></p>\n<h2 id=\"写文章\"><a class=\"markdownIt-Anchor\" href=\"#写文章\"></a> 写文章</h2>\n<ol>\n<li>创建一篇新文章</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">new</span> <span class=\"string\">[layout]</span> <span class=\"string\">&lt;title&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>指定分类和标签</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 用 -的形式只能写一个分类</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 若想用多个分类则：categories:</span></span><br><span class=\"line\"><span class=\"comment\"># \t\t\t\t\t\t- [Diary, PlayStation]</span></span><br><span class=\"line\"><span class=\"comment\"># \t\t\t\t\t\t- [Diary, Games]</span></span><br><span class=\"line\"><span class=\"comment\"># \t\t\t\t\t\t- [Life]</span></span><br><span class=\"line\"><span class=\"attr\">categories:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Diary</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">PS3</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">Games</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>\n<p>文章摘要和截断</p>\n<p>在文章中使用<code>&lt;!--more--&gt;</code>，那么之前的文字将会被视为<strong>摘要</strong>。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中</p>\n</li>\n</ol>\n<h3 id=\"写文章之插入图片\"><a class=\"markdownIt-Anchor\" href=\"#写文章之插入图片\"></a> 写文章之插入图片</h3>\n<ol>\n<li>统一存放</li>\n</ol>\n<p><img src=\"/images/aidang.jpg\" alt=\"H\"></p>\n<ul>\n<li>优点：在首页内容和文章正文中都能正常显示,十分方便</li>\n<li>缺点：\n<ol>\n<li>因为相对路径不一致,找不到文件，本地markdown 编辑器无法预览</li>\n<li>图片几乎无法维护</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>生成每篇文章专属图片文件夹：在<code>_config.yml</code>配置</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>配置后怎么用：当用 <code>hexo new article_name</code> 命令时，不仅会在 <code>source/_post</code> 文件夹自动生成文件： <code>article_name.md</code>还会生成同名文件夹： <code>source/_post/article_name</code>，这样就可以直接通过资源名引用了</p>\n<p>举例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 图片位置：source/_posts/article_name/image.jpg</span></span><br><span class=\"line\"><span class=\"comment\"># 直接引用：</span></span><br><span class=\"line\"><span class=\"string\">![](image.jpg)</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/police.jpg\" alt=\"H\"></p>\n</li>\n</ol>\n<h2 id=\"一键部署将-hexo-部署到-github-pages\"><a class=\"markdownIt-Anchor\" href=\"#一键部署将-hexo-部署到-github-pages\"></a> 一键部署：将 Hexo 部署到 GitHub Pages</h2>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 可选：清除 public文件夹</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\"><span class=\"comment\"># 1、生成（generate）</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">g</span></span><br><span class=\"line\"><span class=\"comment\"># 可选：进行本地预览（server）</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">s</span></span><br><span class=\"line\"><span class=\"comment\"># 2、一键部署（deploy）</span></span><br><span class=\"line\"><span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br></pre></td></tr></table></figure>\n<p>💥</p>\n","excerpt":"记录下hexo的基础用法，同时希望自己能够坚持写下去 🐱‍🏍","categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://weston-wey.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"实用工具/hexo","permalink":"https://weston-wey.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://weston-wey.github.io/tags/hexo/"}]}],"categories":[{"name":"redis设计与实现读书笔记","slug":"redis设计与实现读书笔记","permalink":"https://weston-wey.github.io/categories/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://weston-wey.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"数据结构与算法/剑指offer","permalink":"https://weston-wey.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"},{"name":"实习面经","slug":"实习面经","permalink":"https://weston-wey.github.io/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"},{"name":"实用工具","slug":"实用工具","permalink":"https://weston-wey.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"实用工具/hexo","permalink":"https://weston-wey.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/hexo/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://weston-wey.github.io/tags/redis/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://weston-wey.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://weston-wey.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://weston-wey.github.io/tags/LeetCode/"},{"name":"网易传媒技术部","slug":"网易传媒技术部","permalink":"https://weston-wey.github.io/tags/%E7%BD%91%E6%98%93%E4%BC%A0%E5%AA%92%E6%8A%80%E6%9C%AF%E9%83%A8/"},{"name":"Java实习面经","slug":"Java实习面经","permalink":"https://weston-wey.github.io/tags/Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"},{"name":"hexo","slug":"hexo","permalink":"https://weston-wey.github.io/tags/hexo/"}]}