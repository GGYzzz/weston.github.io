<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Weston&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weston-wey.github.io/"/>
  <updated>2020-06-14T15:58:02.546Z</updated>
  <id>https://weston-wey.github.io/</id>
  
  <author>
    <name>Weston</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>6月14 剑指offer二刷复习</title>
    <link href="https://weston-wey.github.io/6%E6%9C%8814-%E5%89%91%E6%8C%87offer%E4%BA%8C%E5%88%B7%E5%A4%8D%E4%B9%A0/"/>
    <id>https://weston-wey.github.io/6%E6%9C%8814-%E5%89%91%E6%8C%87offer%E4%BA%8C%E5%88%B7%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-06-14T15:49:57.000Z</published>
    <updated>2020-06-14T15:58:02.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-用两个栈实现队列easy"><a class="markdownIt-Anchor" href="#1-用两个栈实现队列easy"></a> 1、<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a>【easy】</h3><ul><li><p>思路：</p><ul><li>栈：先进后出；队列：先进先出</li><li>对于对于一批数据来说，先入栈的，最后出栈；于是，如果要是能把入栈的这一批数据倒叙过来就好了；</li><li><mark>栈有记忆功能</mark>，这正是栈能派上用场的地方！</li><li>因此基本思路就是：一个栈A 尽管入，当要出队时，把这一批数据用另一个栈B 做个倒叙就可以了。</li></ul></li><li><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈即可</span></span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 出队时，把数据全部做一次逆序即可</span></span><br><span class="line">        <span class="keyword">if</span>(!stack2.empty())&#123;</span><br><span class="line">            <span class="comment">// 栈2不空，说明已经有之前逆序过的数据了，直接出队即可；</span></span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 栈2为空</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.empty() ? -<span class="number">1</span> : stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-求斐波那契数列的第-n项easy"><a class="markdownIt-Anchor" href="#2-求斐波那契数列的第-n项easy"></a> 2、<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">求斐波那契数列的第 n项</a>【easy】</h3><ul><li><p>三种思路：</p><ol><li>递归：简单、直观，但是重复计算太大，不可能通过测试用例</li><li>记忆化递归：用数组把算过的值记下来，避免大量重复计算<ul><li>可以解决问题，但是有方法栈的开销</li></ul></li><li>动态规划：自底向上，经过空间优化的空间复杂度可以达到 O(1)</li></ol></li><li><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            res = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-数组中重复的数字返回任一个重复的即可easy"><a class="markdownIt-Anchor" href="#3-数组中重复的数字返回任一个重复的即可easy"></a> 3、<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字，返回任一个重复的即可</a>【easy】</h3><ul><li><p>三种思路：</p><ol><li><mark>集合去重：提到去重，就应想到集合</mark>：遍历一遍并放入HashSet，如果集合中已经有了，那直接返回该值即可</li><li><mark>数组去重：当数组值的范围有限【例如字符串中的字母去重】，可以考虑直接用一定大小的数组去重【比如int[24]】</mark></li><li>该题的特殊点：数组中的值都在 0~n-1之间，因此直接用本身就可以了；原地置换思路：<ol><li>遍历数组，把当前的数字nums[i] 和对应索引的值进行交换</li><li>每一次都会把一个数字放到最终的位置【数字值等于索引值的位置】</li><li>遇到对应位置已经存在相等的值了，说明重复了，直接返回即可</li></ol></li></ol></li><li><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 如果不在最终位置</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="comment">// 交换前判断是否重复</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 需要交换</span></span><br><span class="line">                <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">                nums[i]=nums[nums[i]];</span><br><span class="line">                nums[temp]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-二维数组中查找某个值-target是否存在easy"><a class="markdownIt-Anchor" href="#4-二维数组中查找某个值-target是否存在easy"></a> 4、<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">二维数组中查找某个值 target是否存在</a>【easy】</h3><ul><li><p>两种思路：</p><ol><li><p>直接遍历即可，时间复杂度：O(n^2)</p></li><li><p>二分法，利用二维数组的特殊性：</p><blockquote><p>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</p></blockquote><p>因此不必从头开始遍历，而是利用到数组的特性：从右上角（或左下角）出发，只能向左或者向下走，因为左边的值都小于当前值，而下变的值都大于当前值。因此每一步必定要么向左，要么向下，从而充分利用了数组的特性，达到了“二分法”的效果</p><ul><li>时间复杂度：O(max(rows, cols))</li></ul></li></ol></li></ul><h3 id="5-青蛙跳台阶问题easy"><a class="markdownIt-Anchor" href="#5-青蛙跳台阶问题easy"></a> 5、<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" target="_blank" rel="noopener">青蛙🐸跳台阶问题</a>【easy】</h3><ul><li>与斐波那契数列一摸一样，换了个描述方式而已（直接把斐波那契那道题的代码拷过来就能AC）</li></ul><h3 id="6-旋转数组的最小数字找旋转点easy"><a class="markdownIt-Anchor" href="#6-旋转数组的最小数字找旋转点easy"></a> 6、<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字：找旋转点</a>【easy】</h3><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个<strong>递增排序</strong>的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><ul><li><p>两种思路：</p><ol><li><p>遍历一遍的思路谁都想的出来，时间复杂度 O(n)；【O(n)已经挺好的了呀，于是进一步优化至 O(logn)】</p></li><li><p><mark>提到有序数组的查找，就应立马想到二分法：时间复杂度O(logn)</mark>，但这是一个不完全有序的数组，还能用到二分法吗？答案是肯定的。</p></li></ol></li><li><p>实现：【算法流程可以画图理解，清晰的一b】</p><ol><li>一般情况：（用来写算法框架）</li></ol><p><img src="/6%E6%9C%8814-%E5%89%91%E6%8C%87offer%E4%BA%8C%E5%88%B7%E5%A4%8D%E4%B9%A0/image-20200614231556957.png" alt="normal"></p><ol start="2"><li>特殊情况：（用来考虑算法细节，真正需要debug的地方在这里！）<ul><li>[1，2，3，4，5]，旋转个数为0</li><li>[1，1，1，0，1]、[1，0，1，1，1]，很鸡贼的旋转</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123; <span class="comment">// 找旋转点</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=numbers.length-<span class="number">1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&gt;numbers[right])&#123; <span class="comment">//旋转点一定在右边</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&lt;numbers[right])&#123; <span class="comment">//当前有可能踩着旋转点</span></span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//当前有可能踩着旋转点</span></span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-用两个栈实现队列easy&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-用两个栈实现队列easy&quot;&gt;&lt;/a&gt; 1、&lt;a href=&quot;https://leetcode-cn.com/problems/yong-liang-ge-z
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://weston-wey.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://weston-wey.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://weston-wey.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="LeetCode" scheme="https://weston-wey.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>网易传媒Java实习面经</title>
    <link href="https://weston-wey.github.io/%E7%BD%91%E6%98%93%E4%BC%A0%E5%AA%92Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    <id>https://weston-wey.github.io/%E7%BD%91%E6%98%93%E4%BC%A0%E5%AA%92Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-06-14T08:42:24.000Z</published>
    <updated>2020-06-14T09:13:09.393Z</updated>
    
    <content type="html"><![CDATA[<p>记录面经，许愿offer。</p><a id="more"></a><h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2><ol><li><p>知道哪些集合</p></li><li><p>HashMap底层原理（每次都问这个我都吐了）</p></li><li><p>怎么让 HashMap退化成链表</p></li><li><ul><li>他想说 重写hashcode方法，说了半天都没答到他想知道的点</li></ul></li><li><p>对红黑树的了解？【这个太麻烦了，我每次都说红黑树是一个类似平衡二叉树的东西，其他就没有了】</p></li><li><p>你对多线程的了解有哪些</p></li><li><p>线程池如何去实现</p></li><li><p>线程池的处理流程</p></li><li><p>线程池创建的几个参数</p></li><li><p><mark>你搞的项目有用到线程池吗</mark></p></li><li><p><mark>为什么要有多线程</mark></p></li><li><p>多线程一定会加速程序的执行吗</p></li></ol><h2 id="电话也能问算法"><a class="markdownIt-Anchor" href="#电话也能问算法"></a> 电话也能问算法</h2><ol><li><p>如何判断链表是否有环【2种方法】</p></li><li><p>爬楼梯/青蛙跳台阶 /斐波那契数列【动态规划】</p></li><li><p>MySQL索引，对 B+树的理解</p></li><li><p>二叉树，平衡二叉树，B树，为什么要选用 B+树做索引</p></li><li><p>设计模式，单例模式</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录面经，许愿offer。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实习面经" scheme="https://weston-wey.github.io/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="网易传媒技术部" scheme="https://weston-wey.github.io/tags/%E7%BD%91%E6%98%93%E4%BC%A0%E5%AA%92%E6%8A%80%E6%9C%AF%E9%83%A8/"/>
    
      <category term="Java实习面经" scheme="https://weston-wey.github.io/tags/Java%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo简单使用手册</title>
    <link href="https://weston-wey.github.io/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://weston-wey.github.io/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2020-06-14T08:34:29.000Z</published>
    <updated>2020-06-14T10:21:12.602Z</updated>
    
    <content type="html"><![CDATA[<p>记录下hexo的基础用法，同时希望自己能够坚持写下去 🐱‍🏍</p><a id="more"></a><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>安装就暂时先略过，可参考其他教程，本篇主要记录 hexo的使用；插眼：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo中文文档</a></p><h2 id="写文章"><a class="markdownIt-Anchor" href="#写文章"></a> 写文章</h2><ol><li>创建一篇新文章</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">[layout]</span> <span class="string">&lt;title&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指定分类和标签</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 用 -的形式只能写一个分类</span></span><br><span class="line"><span class="comment"># 2. 若想用多个分类则：categories:</span></span><br><span class="line"><span class="comment"># - [Diary, PlayStation]</span></span><br><span class="line"><span class="comment"># - [Diary, Games]</span></span><br><span class="line"><span class="comment"># - [Life]</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>文章摘要和截断</p><p>在文章中使用<code>&lt;!--more--&gt;</code>，那么之前的文字将会被视为<strong>摘要</strong>。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中</p></li></ol><h3 id="写文章之插入图片"><a class="markdownIt-Anchor" href="#写文章之插入图片"></a> 写文章之插入图片</h3><ol><li>统一存放</li></ol><p><img src="/images/aidang.jpg" alt="H"></p><ul><li>优点：在首页内容和文章正文中都能正常显示,十分方便</li><li>缺点：<ol><li>因为相对路径不一致,找不到文件，本地markdown 编辑器无法预览</li><li>图片几乎无法维护</li></ol></li></ul><ol start="2"><li><p>生成每篇文章专属图片文件夹：在<code>_config.yml</code>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置后怎么用：当用 <code>hexo new article_name</code> 命令时，不仅会在 <code>source/_post</code> 文件夹自动生成文件： <code>article_name.md</code>还会生成同名文件夹： <code>source/_post/article_name</code>，这样就可以直接通过资源名引用了</p><p>举例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片位置：source/_posts/article_name/image.jpg</span></span><br><span class="line"><span class="comment"># 直接引用：</span></span><br><span class="line"><span class="string">![](image.jpg)</span></span><br></pre></td></tr></table></figure><p><img src="/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/police.jpg" alt="H"></p></li></ol><h2 id="一键部署将-hexo-部署到-github-pages"><a class="markdownIt-Anchor" href="#一键部署将-hexo-部署到-github-pages"></a> 一键部署：将 Hexo 部署到 GitHub Pages</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可选：清除 public文件夹</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="comment"># 1、生成（generate）</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="comment"># 可选：进行本地预览（server）</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">s</span></span><br><span class="line"><span class="comment"># 2、一键部署（deploy）</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><p>💥</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下hexo的基础用法，同时希望自己能够坚持写下去 🐱‍🏍&lt;/p&gt;
    
    </summary>
    
    
      <category term="实用工具" scheme="https://weston-wey.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="https://weston-wey.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
      <category term="hexo" scheme="https://weston-wey.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
